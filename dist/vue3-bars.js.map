{"version":3,"file":"vue3-bars.js","sources":["../src/helpers/gradient.ts","../src/helpers/path.ts","../src/components/PathGroup.vue","../src/components/VueBars.vue","../src/index.ts"],"sourcesContent":["function transitionColor(from: string, to: string, count: number): string[] {\n  count = count + 1\n  const int = parseInt(from, 16) // 100\n  const intTo = parseInt(to, 16) // 50\n  const list: string[] = [] // 5\n  const diff = int - intTo // 50\n  const one = diff / count // 10\n\n  list.push(from)\n  for (let i = 1; i <= count; i++) {\n    // Ensure hex value is padded if needed (e.g., 'f' -> '0f')\n    const hex = Math.floor(int - one * i).toString(16)\n    list.push(hex.length === 1 ? '0' + hex : hex)\n  }\n\n  return list\n}\n\nfunction transition(from: string, to: string, count: number = 3): string[] {\n  const r = from.slice(0, 2)\n  const g = from.slice(2, 4)\n  const b = from.slice(4, 6)\n  const rt = to.slice(0, 2)\n  const gt = to.slice(2, 4)\n  const bt = to.slice(4, 6)\n  const allR = transitionColor(r, rt, count)\n  const allG = transitionColor(g, gt, count)\n  const allB = transitionColor(b, bt, count)\n  const list: string[] = []\n\n  allR.forEach((_, i) => {\n    list.push('' + allR[i] + allG[i] + allB[i])\n  })\n\n  return list\n}\n\n/**\n * Generates an array of hex color strings for a gradient.\n * @param from - Starting color hex (e.g., '#ff0000')\n * @param to - Ending color hex (e.g., '#0000ff')\n * @param count - Number of steps between from and to.\n * @returns Array of hex color strings including from and to.\n */\nexport function generateGradientStepsCss(from: string, to: string, count: number): string[] {\n  from = from.replace('#', '')\n  to = to.replace('#', '')\n  const values = transition(from, to, count)\n  return values.map((val) => '#' + val)\n}\n","import { generateGradientStepsCss } from './gradient'\n\n// Types\ninterface Point {\n  x: number\n  y: number\n  height: number\n  title: string | number\n  zeroLineY: number // Make zeroLineY required\n}\n\ninterface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  minBarHeight: number\n}\n\ninterface PointInput {\n  value: number\n  title?: string | number\n}\n\ninterface BarProps {\n  gradient: string[]\n  barWidth?: number\n  padding?: number\n  rounding?: number\n  growDuration: number\n}\n\ninterface LabelProps {\n  labelData: (string | number)[]\n  labelRotate: number\n  labelColor: string\n  labelSize: number\n  labelHeight: number\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\n// Return type for genBarsData\ninterface BarData {\n  id: string\n  fill: string\n  x: number\n  y: number\n  width: number\n  height: number\n  rx: number\n  ry: number\n  title: string | number\n  growDuration: number\n}\n\n// Return type for genLabelsData\ninterface LabelData {\n  x: number\n  y: number\n  transformText: string\n  text: string | number\n  style: string\n  title: string | number\n}\n\n/**\n * Calculate the coordinate points for the bars.\n */\nexport function genPoints(\n  inArr: (number | PointInput)[],\n  { minX, minY, maxX, maxY, minBarHeight }: Boundary,\n  barWidth: number,\n  { max, min }: { max: number; min: number },\n  labelProps: LabelProps // Used to check if labels exist\n): Point[] {\n  const arr = inArr.map((item) => (typeof item === 'number' ? item : item.value))\n  const minValue = Math.min(...arr, min === Infinity ? (arr.length ? Math.min(...arr) : 0) : min)\n  const maxValue = Math.max(...arr, max === -Infinity ? (arr.length ? Math.max(...arr) : 0) : max)\n  const absMaxVal = Math.abs(maxValue)\n  const absMinVal = Math.abs(minValue)\n  const gridX = arr.length > 1 ? (maxX - minX - barWidth) / (arr.length - 1) : maxX - minX // Handle single data point\n  const labelHeight = labelProps.labelData.length > 0 ? labelProps.labelHeight : 0 // Adjust space if labels are present\n\n  let delta = 0\n  if (minValue < 0 && maxValue <= 0) {\n    // Handle case where all values are negative or zero\n    delta = absMinVal\n  } else if (minValue < 0 && maxValue > 0) {\n    delta = absMinVal + absMaxVal\n  } else {\n    // minValue >= 0 && maxValue >= 0\n    delta = maxValue\n  }\n\n  // Prevent division by zero if delta is 0 and handle case where maxY equals minY\n  const availableHeight = maxY - minY - labelHeight\n  const heightMultiplier = delta !== 0 && availableHeight > 0 ? availableHeight / delta : 1\n\n  // Adjust y baseline if minimum value causes bars to be too small\n  const yAdjust =\n    minValue >= 0 && minValue * heightMultiplier < minBarHeight\n      ? 0\n      : minValue < 0 && absMinVal * heightMultiplier < minBarHeight\n        ? minBarHeight - absMinVal * heightMultiplier\n        : 0\n\n  const zeroLineY =\n    minValue < 0 ? maxY - labelHeight - absMinVal * heightMultiplier : maxY - labelHeight\n\n  return arr.map((value, index) => {\n    const title =\n      typeof inArr[index] === 'number'\n        ? String(inArr[index])\n        : ((inArr[index] as PointInput).title ?? String(value))\n    const height = Math.abs(value) * heightMultiplier\n    // Ensure minimum bar height, account for yAdjust\n    const barHeight = Math.max(height - (value >= 0 ? 0 : yAdjust), minBarHeight)\n\n    return {\n      x: arr.length > 1 ? index * gridX + minX : minX + (maxX - minX - barWidth) / 2,\n      // If value is negative, y starts at zeroLine, otherwise it's zeroLine - barHeight\n      y: value >= 0 ? zeroLineY - barHeight : zeroLineY,\n      height: barHeight,\n      title: title,\n      zeroLineY // Add zeroLineY to point data\n    }\n  })\n}\n\n/**\n * Generates data properties for bar rectangles.\n */\nexport function genBarsData(\n  points: Point[],\n  props: BarProps & Boundary // Combine types for easier access\n): BarData[] {\n  const { maxX, gradient, growDuration } = props\n  const barWidth =\n    props.barWidth ??\n    (points.length > 1\n      ? maxX / (points.length - 1) - (props.padding ?? 5)\n      : maxX - props.minX - (props.padding ?? 5) * 2) // Use full width if only one point\n  const rounding = props.rounding ?? 2\n  let gradients: string[] = []\n  if (gradient && gradient.length > 1 && points.length > 1) {\n    gradients = generateGradientStepsCss(gradient[0], gradient[1], points.length - 1)\n  } else if (gradient && gradient.length > 0) {\n    gradients = points.map(() => gradient[0]) // Single color gradient\n  } else {\n    gradients = points.map(() => '#000') // Default color\n  }\n  return points.map((item, index) => ({\n    id: `bar-id-${index}`,\n    fill: gradients[index] || gradient[0] || '#000',\n    x: item.x, // Adjust x for single point\n    y: item.y,\n    width: barWidth,\n    height: item.height,\n    rx: rounding,\n    ry: rounding,\n    title: item.title,\n    growDuration: growDuration\n  }))\n}\n\n/**\n * Generates data properties for x-axis labels.\n */\nexport function genLabelsData(\n  points: Point[],\n  props: LabelProps & Pick<BarProps, 'barWidth' | 'padding'>\n): LabelData[] {\n  const { labelData, labelRotate, labelColor, labelSize } = props\n  if (!labelData || labelData.length === 0 || !points.length) return []\n\n  // Add safety check and fallback\n  const labelY = props.maxY - props.labelHeight + 10 // Add consistent padding below zero line\n\n  return points\n    .map((point, index) => {\n      if (index >= labelData.length) return null\n      const title = labelData[index]\n      const labelX = point.x + (props.barWidth || 0) - labelSize / 2 // Center label on bar\n      return {\n        x: labelX,\n        y: labelY,\n        transformText: `rotate(${labelRotate}, ${labelX}, ${labelY})`,\n        style: `text-anchor: end; fill:${labelColor}; font-size:${labelSize}px; user-select: none;`,\n        text: title,\n        title: point.title\n      }\n    })\n    .filter((item): item is LabelData => item !== null)\n}\n","<script setup lang=\"ts\">\nimport { computed, type PropType } from 'vue'\nimport { genBarsData, genLabelsData, genPoints } from '../helpers/path'\n\n// Define types for props based on helper types\ninterface PointInput {\n  value: number\n  title?: string | number\n}\n\ninterface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  minBarHeight: number\n}\n\ninterface LabelProps {\n  labelData: (string | number)[]\n  labelRotate: number\n  labelColor: string\n  labelSize: number\n  labelHeight: number\n  minX: number // Needed for genLabelsData calculation\n  minY: number // Needed for genLabelsData calculation (though unused currently)\n  maxX: number // Needed for genLabelsData calculation\n  maxY: number // Needed for genLabelsData calculation\n}\n\nconst props = defineProps({\n  data: {\n    type: Array as PropType<(number | PointInput)[]>,\n    required: true\n  },\n  boundary: {\n    type: Object as PropType<Boundary>,\n    required: true\n  },\n  barWidth: {\n    type: Number,\n    default: 8 // Allow helper to calculate default\n  },\n  rounding: {\n    type: Number,\n    default: 2\n  },\n  gradient: {\n    type: Array as PropType<string[]>,\n    default: () => ['#000']\n  },\n  growDuration: {\n    type: Number,\n    default: 0.5\n  },\n  max: {\n    type: Number,\n    default: -Infinity\n  },\n  min: {\n    type: Number,\n    default: Infinity\n  },\n  labelProps: {\n    // Combine label-related props\n    type: Object as PropType<LabelProps>,\n    required: true\n  },\n  padding: {\n    // Pass padding for barWidth calculation in helpers\n    type: Number,\n    default: 8\n  }\n})\n\n// Calculate points\nconst points = computed(() => {\n  if (!props.data || props.data.length === 0) return []\n  // Ensure props.min and props.max are numbers before passing\n  const minVal = typeof props.min === 'number' ? props.min : -Infinity\n  const maxVal = typeof props.max === 'number' ? props.max : Infinity\n  return genPoints(\n    props.data,\n    props.boundary,\n    props.barWidth,\n    { max: maxVal, min: minVal },\n    props.labelProps\n  )\n})\n// console.log('points', points.value)\n\n// Generate bar data for the template\nconst barsData = computed(() => {\n  if (!points.value.length) return []\n  return genBarsData(points.value, {\n    // Pass combined props needed by genBarsData\n    gradient: props.gradient,\n    barWidth: props.barWidth,\n    padding: props.padding,\n    rounding: props.rounding,\n    growDuration: props.growDuration,\n    ...props.boundary // Spread boundary props\n  })\n})\n// console.log('barsData', barsData.value)\n\n// Generate label data for the template\nconst labelsData = computed(() => {\n  if (!points.value.length || !props.labelProps.labelData?.length) return []\n  return genLabelsData(points.value, {\n    // Pass combined props needed by genLabelsData\n    labelData: props.labelProps.labelData,\n    labelRotate: props.labelProps.labelRotate,\n    labelColor: props.labelProps.labelColor,\n    labelSize: props.labelProps.labelSize,\n    labelHeight: props.labelProps.labelHeight,\n    barWidth: props.barWidth, // Pass barWidth for calculation\n    padding: props.padding, // Pass padding for calculation\n    minX: props.labelProps.minX,\n    minY: props.labelProps.minY,\n    maxX: props.labelProps.maxX,\n    maxY: props.labelProps.maxY\n  })\n})\n// console.log('labelsData', labelsData.value)\n</script>\n\n<template>\n  <g class=\"container\" :transform=\"`translate(0, 0)`\">\n    <!-- Render Bars -->\n    <rect\n      v-for=\"bar in barsData\"\n      :key=\"bar.id\"\n      :id=\"bar.id\"\n      :fill=\"bar.fill\"\n      :x=\"bar.x\"\n      :y=\"bar.y\"\n      :width=\"bar.width\"\n      :height=\"bar.height\"\n      :rx=\"bar.rx\"\n      :ry=\"bar.ry\"\n    >\n      <!-- Animation -->\n      <animate\n        attributeName=\"height\"\n        from=\"0\"\n        :to=\"bar.height\"\n        :dur=\"`${bar.growDuration}s`\"\n        fill=\"freeze\"\n      />\n      <animate\n        attributeName=\"y\"\n        :from=\"boundary.maxY - (props.labelProps.labelData.length > 0 ? 20 : 0)\"\n        :to=\"bar.y\"\n        :dur=\"`${bar.growDuration}s`\"\n        fill=\"freeze\"\n      />\n      <title>{{ bar.title }}</title>\n    </rect>\n\n    <!-- Render Labels -->\n    <text\n      v-for=\"(label, index) in labelsData\"\n      :key=\"`label-${index}`\"\n      class=\"v-bars--label-text\"\n      :style=\"label.style\"\n      :x=\"label.x\"\n      :y=\"label.y\"\n      :transform=\"label.transformText\"\n    >\n      {{ label.text }}\n    </text>\n  </g>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, type PropType } from 'vue'\nimport PathGroup from './PathGroup.vue' // Import the new Path component\n\n// Define the type for individual data points\ninterface PointInput {\n  value: number\n  title?: string | number\n}\n\n// Define props using defineProps with TypeScript\nconst props = defineProps({\n  data: {\n    type: Array as PropType<(number | PointInput)[]>,\n    required: true\n  },\n  // autoDraw: Boolean, // This prop seems unused, omitting for now unless needed\n  barWidth: {\n    type: Number,\n    default: 8 // Default can be managed here or within Path.vue/helpers\n  },\n  rounding: {\n    type: Number,\n    default: 2\n  },\n  growDuration: {\n    type: Number,\n    default: 0.5\n  },\n  gradient: {\n    type: Array as PropType<string[]>,\n    default: () => ['#000']\n  },\n  max: {\n    type: Number,\n    default: -Infinity\n  },\n  min: {\n    type: Number,\n    default: Infinity\n  },\n  minBarHeight: {\n    type: Number,\n    default: 3\n  },\n  labelData: {\n    type: Array as PropType<(string | number)[]>,\n    default: () => []\n  },\n  labelRotate: {\n    type: Number,\n    default: -45\n  },\n  labelColor: {\n    type: String,\n    default: '#999'\n  },\n  labelSize: {\n    type: Number,\n    default: 10\n  },\n  labelHeight: {\n    type: Number,\n    default: 20\n  },\n  height: {\n    type: String\n  },\n  width: {\n    type: String\n  },\n  viewHeight: {\n    type: Number,\n    default: 75 // Default height if not provided\n  },\n  viewWidth: {\n    type: Number,\n    default: 300 // Default width if not provided\n  },\n  padding: {\n    type: Number,\n    default: 8\n  },\n  svgStyle: {\n    type: Object,\n    default: () => ({\n      display: 'block' /* Prevent inline spacing issues */,\n      overflow: 'visible' /* Allow labels/elements outside viewBox if needed */\n    })\n  }\n})\n\n// Computed property to determine if the component should render\nconst shouldRender = computed(() => props.data && props.data.length >= 1) // Allow rendering even with 1 bar\n\n// SVG dimensions and viewBox\nconst svgWidth = computed(() => (props.width ? `${props.width}` : '100%'))\nconst svgHeight = computed(() => (props.height ? `${props.height}` : '100%'))\nconst viewWidth = computed(() => props.viewWidth)\nconst viewHeight = computed(() => props.viewHeight)\nconst viewBox = computed(() => `0 0 ${viewWidth.value} ${viewHeight.value}`)\n\n// Calculated boundary object to pass to Path component\nconst boundary = computed(() => ({\n  minX: props.padding,\n  minY: props.padding,\n  maxX: viewWidth.value - props.padding,\n  maxY: viewHeight.value - props.padding,\n  minBarHeight: props.minBarHeight\n}))\n\n// Combined label properties object to pass to Path component\nconst labelProps = computed(() => ({\n  labelData: props.labelData,\n  labelRotate: props.labelRotate,\n  labelColor: props.labelColor,\n  labelSize: props.labelSize,\n  labelHeight: props.labelHeight,\n  // Pass boundary coordinates needed for label calculation\n  minX: boundary.value.minX,\n  minY: boundary.value.minY,\n  maxX: boundary.value.maxX,\n  maxY: boundary.value.maxY\n}))\n</script>\n\n<template>\n  <svg\n    v-if=\"shouldRender\"\n    :width=\"svgWidth\"\n    :height=\"svgHeight\"\n    :viewBox=\"viewBox\"\n    :style=\"svgStyle\"\n    class=\"vue-bars\"\n  >\n    <PathGroup\n      :data=\"props.data\"\n      :boundary=\"boundary\"\n      :barWidth=\"props.barWidth\"\n      :rounding=\"props.rounding\"\n      :gradient=\"props.gradient\"\n      :growDuration=\"props.growDuration\"\n      :max=\"props.max\"\n      :min=\"props.min\"\n      :labelProps=\"labelProps\"\n      :padding=\"props.padding\"\n    />\n  </svg>\n</template>\n\n<style scoped></style>\n","import type { App, Plugin } from 'vue'\nimport VueBarsComponent from './components/VueBars.vue'\n\nconst install: Plugin = (app: App) => {\n  app.component('VueBars', VueBarsComponent)\n}\n\n// Attach the install function directly to the component object.\n// Use a type assertion with an intersection type to inform TypeScript\n// that this object now also has an 'install' property.\nconst VueBars = VueBarsComponent as typeof VueBarsComponent & { install: Plugin }\nVueBars.install = install\n\nexport default VueBars\n"],"names":["transitionColor","from","to","count","int","intTo","list","one","hex","transition","r","g","b","rt","gt","bt","allR","allG","allB","_","i","generateGradientStepsCss","val","genPoints","inArr","minX","minY","maxX","maxY","minBarHeight","barWidth","max","min","labelProps","arr","item","minValue","maxValue","absMaxVal","absMinVal","gridX","labelHeight","delta","availableHeight","heightMultiplier","yAdjust","zeroLineY","value","index","title","height","barHeight","genBarsData","points","props","gradient","growDuration","rounding","gradients","genLabelsData","labelData","labelRotate","labelColor","labelSize","labelY","point","labelX","__props","computed","minVal","maxVal","barsData","labelsData","_a","shouldRender","svgWidth","svgHeight","viewWidth","viewHeight","viewBox","boundary","install","app","VueBarsComponent","VueBars"],"mappings":"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"}