{"version":3,"file":"vue3-bars.umd.cjs","sources":["../src/helpers/gradient.ts","../src/helpers/path.ts","../src/components/PathGroup.vue","../src/components/VueBars.vue"],"sourcesContent":["function transitionColor(from: string, to: string, count: number): string[] {\n  count = count + 1\n  const int = parseInt(from, 16) // 100\n  const intTo = parseInt(to, 16) // 50\n  const list: string[] = [] // 5\n  const diff = int - intTo // 50\n  const one = diff / count // 10\n\n  list.push(from)\n  for (let i = 1; i <= count; i++) {\n    // Ensure hex value is padded if needed (e.g., 'f' -> '0f')\n    const hex = Math.floor(int - one * i).toString(16)\n    list.push(hex.length === 1 ? '0' + hex : hex)\n  }\n\n  return list\n}\n\nfunction transition(from: string, to: string, count: number = 3): string[] {\n  const r = from.slice(0, 2)\n  const g = from.slice(2, 4)\n  const b = from.slice(4, 6)\n  const rt = to.slice(0, 2)\n  const gt = to.slice(2, 4)\n  const bt = to.slice(4, 6)\n  const allR = transitionColor(r, rt, count)\n  const allG = transitionColor(g, gt, count)\n  const allB = transitionColor(b, bt, count)\n  const list: string[] = []\n\n  allR.forEach((_, i) => {\n    list.push('' + allR[i] + allG[i] + allB[i])\n  })\n\n  return list\n}\n\n/**\n * Generates an array of hex color strings for a gradient.\n * @param from - Starting color hex (e.g., '#ff0000')\n * @param to - Ending color hex (e.g., '#0000ff')\n * @param count - Number of steps between from and to.\n * @returns Array of hex color strings including from and to.\n */\nexport function generateGradientStepsCss(from: string, to: string, count: number): string[] {\n  from = from.replace('#', '')\n  to = to.replace('#', '')\n  const values = transition(from, to, count)\n  return values.map((val) => '#' + val)\n}\n","import { generateGradientStepsCss } from './gradient'\n\n// Types\ninterface Point {\n  x: number\n  y: number\n  height: number\n  title: string | number\n  zeroLineY: number // Make zeroLineY required\n}\n\ninterface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  minBarHeight: number\n}\n\ninterface PointInput {\n  value: number\n  title?: string | number\n}\n\ninterface BarProps {\n  gradient: string[]\n  barWidth?: number\n  padding?: number\n  rounding?: number\n  growDuration: number\n}\n\ninterface LabelProps {\n  labelData: (string | number)[]\n  labelRotate: number\n  labelColor: string\n  labelSize: number\n  labelHeight: number\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\n// Return type for genBarsData\ninterface BarData {\n  id: string\n  fill: string\n  x: number\n  y: number\n  width: number\n  height: number\n  rx: number\n  ry: number\n  title: string | number\n  growDuration: number\n}\n\n// Return type for genLabelsData\ninterface LabelData {\n  x: number\n  y: number\n  transformText: string\n  text: string | number\n  style: string\n  title: string | number\n}\n\n/**\n * Calculate the coordinate points for the bars.\n */\nexport function genPoints(\n  inArr: (number | PointInput)[],\n  { minX, minY, maxX, maxY, minBarHeight }: Boundary,\n  barWidth: number,\n  { max, min }: { max: number; min: number },\n  labelProps: LabelProps // Used to check if labels exist\n): Point[] {\n  const arr = inArr.map((item) => (typeof item === 'number' ? item : item.value))\n  const minValue = Math.min(...arr, min === Infinity ? (arr.length ? Math.min(...arr) : 0) : min)\n  const maxValue = Math.max(...arr, max === -Infinity ? (arr.length ? Math.max(...arr) : 0) : max)\n  const absMaxVal = Math.abs(maxValue)\n  const absMinVal = Math.abs(minValue)\n  const gridX = arr.length > 1 ? (maxX - minX - barWidth) / (arr.length - 1) : maxX - minX // Handle single data point\n  const labelHeight = labelProps.labelData.length > 0 ? labelProps.labelHeight : 0 // Adjust space if labels are present\n\n  let delta = 0\n  if (minValue < 0 && maxValue <= 0) {\n    // Handle case where all values are negative or zero\n    delta = absMinVal\n  } else if (minValue < 0 && maxValue > 0) {\n    delta = absMinVal + absMaxVal\n  } else {\n    // minValue >= 0 && maxValue >= 0\n    delta = maxValue\n  }\n\n  // Prevent division by zero if delta is 0 and handle case where maxY equals minY\n  const availableHeight = maxY - minY - labelHeight\n  const heightMultiplier = delta !== 0 && availableHeight > 0 ? availableHeight / delta : 1\n\n  // Adjust y baseline if minimum value causes bars to be too small\n  const yAdjust =\n    minValue >= 0 && minValue * heightMultiplier < minBarHeight\n      ? 0\n      : minValue < 0 && absMinVal * heightMultiplier < minBarHeight\n        ? minBarHeight - absMinVal * heightMultiplier\n        : 0\n\n  const zeroLineY =\n    minValue < 0 ? maxY - labelHeight - absMinVal * heightMultiplier : maxY - labelHeight\n\n  return arr.map((value, index) => {\n    const title =\n      typeof inArr[index] === 'number'\n        ? String(inArr[index])\n        : ((inArr[index] as PointInput).title ?? String(value))\n    const height = Math.abs(value) * heightMultiplier\n    // Ensure minimum bar height, account for yAdjust\n    const barHeight = Math.max(height - (value >= 0 ? 0 : yAdjust), minBarHeight)\n\n    return {\n      x: arr.length > 1 ? index * gridX + minX : minX + (maxX - minX - barWidth) / 2,\n      // If value is negative, y starts at zeroLine, otherwise it's zeroLine - barHeight\n      y: value >= 0 ? zeroLineY - barHeight : zeroLineY,\n      height: barHeight,\n      title: title,\n      zeroLineY // Add zeroLineY to point data\n    }\n  })\n}\n\n/**\n * Generates data properties for bar rectangles.\n */\nexport function genBarsData(\n  points: Point[],\n  props: BarProps & Boundary // Combine types for easier access\n): BarData[] {\n  const { maxX, gradient, growDuration } = props\n  const barWidth =\n    props.barWidth ??\n    (points.length > 1\n      ? maxX / (points.length - 1) - (props.padding ?? 5)\n      : maxX - props.minX - (props.padding ?? 5) * 2) // Use full width if only one point\n  const rounding = props.rounding ?? 2\n  let gradients: string[] = []\n  if (gradient && gradient.length > 1 && points.length > 1) {\n    gradients = generateGradientStepsCss(gradient[0], gradient[1], points.length - 1)\n  } else if (gradient && gradient.length > 0) {\n    gradients = points.map(() => gradient[0]) // Single color gradient\n  } else {\n    gradients = points.map(() => '#000') // Default color\n  }\n  return points.map((item, index) => ({\n    id: `bar-id-${index}`,\n    fill: gradients[index] || gradient[0] || '#000',\n    x: item.x, // Adjust x for single point\n    y: item.y,\n    width: barWidth,\n    height: item.height,\n    rx: rounding,\n    ry: rounding,\n    title: item.title,\n    growDuration: growDuration\n  }))\n}\n\n/**\n * Generates data properties for x-axis labels.\n */\nexport function genLabelsData(\n  points: Point[],\n  props: LabelProps & Pick<BarProps, 'barWidth' | 'padding'>\n): LabelData[] {\n  const { labelData, labelRotate, labelColor, labelSize } = props\n  if (!labelData || labelData.length === 0 || !points.length) return []\n\n  // Add safety check and fallback\n  const labelY = props.maxY - props.labelHeight + 10 // Add consistent padding below zero line\n\n  return points\n    .map((point, index) => {\n      if (index >= labelData.length) return null\n      const title = labelData[index]\n      const labelX = point.x + (props.barWidth || 0) - labelSize / 2 // Center label on bar\n      return {\n        x: labelX,\n        y: labelY,\n        transformText: `rotate(${labelRotate}, ${labelX}, ${labelY})`,\n        style: `text-anchor: end; fill:${labelColor}; font-size:${labelSize}px; user-select: none;`,\n        text: title,\n        title: point.title\n      }\n    })\n    .filter((item): item is LabelData => item !== null)\n}\n","<script setup lang=\"ts\">\nimport { computed, type PropType } from 'vue'\nimport { genBarsData, genLabelsData, genPoints } from '../helpers/path'\n\n// Define types for props based on helper types\ninterface PointInput {\n  value: number\n  title?: string | number\n}\n\ninterface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  minBarHeight: number\n}\n\ninterface LabelProps {\n  labelData: (string | number)[]\n  labelRotate: number\n  labelColor: string\n  labelSize: number\n  labelHeight: number\n  minX: number // Needed for genLabelsData calculation\n  minY: number // Needed for genLabelsData calculation (though unused currently)\n  maxX: number // Needed for genLabelsData calculation\n  maxY: number // Needed for genLabelsData calculation\n}\n\nconst props = defineProps({\n  data: {\n    type: Array as PropType<(number | PointInput)[]>,\n    required: true\n  },\n  boundary: {\n    type: Object as PropType<Boundary>,\n    required: true\n  },\n  barWidth: {\n    type: Number,\n    default: 8 // Allow helper to calculate default\n  },\n  rounding: {\n    type: Number,\n    default: 2\n  },\n  gradient: {\n    type: Array as PropType<string[]>,\n    default: () => ['#000']\n  },\n  growDuration: {\n    type: Number,\n    default: 0.5\n  },\n  max: {\n    type: Number,\n    default: -Infinity\n  },\n  min: {\n    type: Number,\n    default: Infinity\n  },\n  labelProps: {\n    // Combine label-related props\n    type: Object as PropType<LabelProps>,\n    required: true\n  },\n  padding: {\n    // Pass padding for barWidth calculation in helpers\n    type: Number,\n    default: 8\n  }\n})\n\n// Calculate points\nconst points = computed(() => {\n  if (!props.data || props.data.length === 0) return []\n  // Ensure props.min and props.max are numbers before passing\n  const minVal = typeof props.min === 'number' ? props.min : -Infinity\n  const maxVal = typeof props.max === 'number' ? props.max : Infinity\n  return genPoints(\n    props.data,\n    props.boundary,\n    props.barWidth,\n    { max: maxVal, min: minVal },\n    props.labelProps\n  )\n})\n// console.log('points', points.value)\n\n// Generate bar data for the template\nconst barsData = computed(() => {\n  if (!points.value.length) return []\n  return genBarsData(points.value, {\n    // Pass combined props needed by genBarsData\n    gradient: props.gradient,\n    barWidth: props.barWidth,\n    padding: props.padding,\n    rounding: props.rounding,\n    growDuration: props.growDuration,\n    ...props.boundary // Spread boundary props\n  })\n})\n// console.log('barsData', barsData.value)\n\n// Generate label data for the template\nconst labelsData = computed(() => {\n  if (!points.value.length || !props.labelProps.labelData?.length) return []\n  return genLabelsData(points.value, {\n    // Pass combined props needed by genLabelsData\n    labelData: props.labelProps.labelData,\n    labelRotate: props.labelProps.labelRotate,\n    labelColor: props.labelProps.labelColor,\n    labelSize: props.labelProps.labelSize,\n    labelHeight: props.labelProps.labelHeight,\n    barWidth: props.barWidth, // Pass barWidth for calculation\n    padding: props.padding, // Pass padding for calculation\n    minX: props.labelProps.minX,\n    minY: props.labelProps.minY,\n    maxX: props.labelProps.maxX,\n    maxY: props.labelProps.maxY\n  })\n})\n// console.log('labelsData', labelsData.value)\n</script>\n\n<template>\n  <g class=\"container\" :transform=\"`translate(0, 0)`\">\n    <!-- Render Bars -->\n    <rect\n      v-for=\"bar in barsData\"\n      :key=\"bar.id\"\n      :id=\"bar.id\"\n      :fill=\"bar.fill\"\n      :x=\"bar.x\"\n      :y=\"bar.y\"\n      :width=\"bar.width\"\n      :height=\"bar.height\"\n      :rx=\"bar.rx\"\n      :ry=\"bar.ry\"\n    >\n      <!-- Animation -->\n      <animate\n        attributeName=\"height\"\n        from=\"0\"\n        :to=\"bar.height\"\n        :dur=\"`${bar.growDuration}s`\"\n        fill=\"freeze\"\n      />\n      <animate\n        attributeName=\"y\"\n        :from=\"boundary.maxY - (props.labelProps.labelData.length > 0 ? 20 : 0)\"\n        :to=\"bar.y\"\n        :dur=\"`${bar.growDuration}s`\"\n        fill=\"freeze\"\n      />\n      <title>{{ bar.title }}</title>\n    </rect>\n\n    <!-- Render Labels -->\n    <text\n      v-for=\"(label, index) in labelsData\"\n      :key=\"`label-${index}`\"\n      class=\"v-bars--label-text\"\n      :style=\"label.style\"\n      :x=\"label.x\"\n      :y=\"label.y\"\n      :transform=\"label.transformText\"\n    >\n      {{ label.text }}\n    </text>\n  </g>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, type PropType } from 'vue'\nimport PathGroup from './PathGroup.vue' // Import the new Path component\n\n// Define the type for individual data points\ninterface PointInput {\n  value: number\n  title?: string | number\n}\n\n// Define props using defineProps with TypeScript\nconst props = defineProps({\n  data: {\n    type: Array as PropType<(number | PointInput)[]>,\n    required: true\n  },\n  // autoDraw: Boolean, // This prop seems unused, omitting for now unless needed\n  barWidth: {\n    type: Number,\n    default: 8 // Default can be managed here or within Path.vue/helpers\n  },\n  rounding: {\n    type: Number,\n    default: 2\n  },\n  growDuration: {\n    type: Number,\n    default: 0.5\n  },\n  gradient: {\n    type: Array as PropType<string[]>,\n    default: () => ['#000']\n  },\n  max: {\n    type: Number,\n    default: -Infinity\n  },\n  min: {\n    type: Number,\n    default: Infinity\n  },\n  minBarHeight: {\n    type: Number,\n    default: 3\n  },\n  labelData: {\n    type: Array as PropType<(string | number)[]>,\n    default: () => []\n  },\n  labelRotate: {\n    type: Number,\n    default: -45\n  },\n  labelColor: {\n    type: String,\n    default: '#999'\n  },\n  labelSize: {\n    type: Number,\n    default: 10\n  },\n  labelHeight: {\n    type: Number,\n    default: 20\n  },\n  height: {\n    type: String\n  },\n  width: {\n    type: String\n  },\n  viewHeight: {\n    type: Number,\n    default: 75 // Default height if not provided\n  },\n  viewWidth: {\n    type: Number,\n    default: 300 // Default width if not provided\n  },\n  padding: {\n    type: Number,\n    default: 8\n  },\n  svgStyle: {\n    type: Object,\n    default: () => ({\n      display: 'block' /* Prevent inline spacing issues */,\n      overflow: 'visible' /* Allow labels/elements outside viewBox if needed */\n    })\n  }\n})\n\n// Computed property to determine if the component should render\nconst shouldRender = computed(() => props.data && props.data.length >= 1) // Allow rendering even with 1 bar\n\n// SVG dimensions and viewBox\nconst svgWidth = computed(() => (props.width ? `${props.width}` : '100%'))\nconst svgHeight = computed(() => (props.height ? `${props.height}` : '100%'))\nconst viewWidth = computed(() => props.viewWidth)\nconst viewHeight = computed(() => props.viewHeight)\nconst viewBox = computed(() => `0 0 ${viewWidth.value} ${viewHeight.value}`)\n\n// Calculated boundary object to pass to Path component\nconst boundary = computed(() => ({\n  minX: props.padding,\n  minY: props.padding,\n  maxX: viewWidth.value - props.padding,\n  maxY: viewHeight.value - props.padding,\n  minBarHeight: props.minBarHeight\n}))\n\n// Combined label properties object to pass to Path component\nconst labelProps = computed(() => ({\n  labelData: props.labelData,\n  labelRotate: props.labelRotate,\n  labelColor: props.labelColor,\n  labelSize: props.labelSize,\n  labelHeight: props.labelHeight,\n  // Pass boundary coordinates needed for label calculation\n  minX: boundary.value.minX,\n  minY: boundary.value.minY,\n  maxX: boundary.value.maxX,\n  maxY: boundary.value.maxY\n}))\n</script>\n\n<template>\n  <svg\n    v-if=\"shouldRender\"\n    :width=\"svgWidth\"\n    :height=\"svgHeight\"\n    :viewBox=\"viewBox\"\n    :style=\"svgStyle\"\n    class=\"vue-bars\"\n  >\n    <PathGroup\n      :data=\"props.data\"\n      :boundary=\"boundary\"\n      :barWidth=\"props.barWidth\"\n      :rounding=\"props.rounding\"\n      :gradient=\"props.gradient\"\n      :growDuration=\"props.growDuration\"\n      :max=\"props.max\"\n      :min=\"props.min\"\n      :labelProps=\"labelProps\"\n      :padding=\"props.padding\"\n    />\n    <!-- Removed ID generation, can be added if needed externally -->\n  </svg>\n  <div v-else>\n    <!-- Optional: message when data is insufficient -->\n    <!-- Not enough data to render bars. -->\n  </div>\n</template>\n\n<style scoped></style>\n"],"names":["transitionColor","from","to","count","int","intTo","list","one","i","hex","transition","r","g","b","rt","gt","bt","allR","allG","allB","generateGradientStepsCss","val","genPoints","inArr","minX","minY","maxX","maxY","minBarHeight","barWidth","max","min","labelProps","arr","item","minValue","maxValue","absMaxVal","absMinVal","gridX","labelHeight","delta","availableHeight","heightMultiplier","yAdjust","zeroLineY","value","index","title","height","barHeight","genBarsData","points","props","gradient","growDuration","rounding","gradients","genLabelsData","labelData","labelRotate","labelColor","labelSize","labelY","point","labelX","__props","computed","minVal","maxVal","barsData","labelsData","_a","shouldRender","svgWidth","svgHeight","viewWidth","viewHeight","viewBox","boundary"],"mappings":"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"}